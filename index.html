<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>My n8n Chatbot</title>
  <style>
    :root { --bg:#0b1020; --panel:#151c34; --text:#e8ecff; --muted:#9aa6d1; --accent:#7aa2ff; }
    * { box-sizing:border-box; }

    /* Page never scrolls; chat area scrolls */
    html, body { height: 100%; overflow: hidden; }
    body { margin:0; background:var(--bg); color:var(--text); font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; }

    .wrap { height: 100dvh; display:flex; flex-direction:column; gap:16px; max-width:780px; margin:0 auto; padding: clamp(12px, 3vw, 24px); }
    header { display:flex; align-items:center; justify-content:space-between; gap:8px; }
    h1 { font-size: 18px; margin:0; font-weight:600; letter-spacing:.2px; }
    .actions { display:flex; gap:8px; }
    button, .btn { background:var(--panel); color:var(--text); border:1px solid #263056; padding:10px 12px; border-radius:12px; cursor:pointer; }
    button:hover { border-color:#33406f; }

    .chat { flex:1; overflow:auto; display:flex; flex-direction:column; gap:10px; padding:4px; }
    .msg { padding:12px 14px; border-radius:14px; line-height:1.4; max-width:85%; white-space:pre-wrap; }
    .user { align-self:flex-end; background:#1d2545; border:1px solid #2d3763; }
    .bot { align-self:flex-start; background:#0f1430; border:1px solid #263056; }
    .muted { color:var(--muted); font-size:12px; }

    form { display:flex; gap:10px; align-items:center; }
    textarea { flex:1; background:#0f1430; color:var(--text); border:1px solid #263056; border-radius:12px; padding:12px; min-height:50px; max-height:200px; resize:vertical; }
    .send { padding:12px 16px; }

    .footer { display:flex; justify-content:space-between; align-items:center; }
    .tiny { font-size:12px; color:var(--muted); }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>ðŸ¤– Moe's BOT</h1>
      <div class="actions">
        <button id="clear">Clear chat</button>
        <button id="export">Export</button>
      </div>
    </header>

    <div id="chat" class="chat"></div>

    <form id="composer">
      <textarea id="input" placeholder="Type a message..." rows="2" enterkeyhint="send"></textarea>
      <input type="file" id="fileInput" style="display:none" multiple />
      <button type="button" id="attach" title="Attach files">ðŸ“Ž</button>
      <button class="send" type="submit">Send</button>
    </form>

    <div class="footer">
      <span class="tiny">Powered by Moe</span>
      <span class="tiny" id="status"></span>
    </div>
  </div>

  <script>
    // ==== CONFIG ====
    const WORKER_PROXY_URL = 'https://lessonplans.ftwmido.workers.dev/'; // your Worker URL
    const prefersDark = true;
    const SEND_ONLY_LAST = true;      // send only latest user message to n8n
    const MAX_CONTEXT_TO_SEND = 1;    // (ignored when SEND_ONLY_LAST = true)
    const MAX_BYTES = 5 * 1024 * 1024; // 5 MB cap per file

    if (prefersDark) document.documentElement.classList.add('dark');

    // ==== ELEMENTS ====
    const chatEl = document.getElementById('chat');
    const form = document.getElementById('composer');
    const input = document.getElementById('input');
    const statusEl = document.getElementById('status');
    const clearBtn = document.getElementById('clear');
    const exportBtn = document.getElementById('export');
    const fileInput = document.getElementById('fileInput');
    const attachBtn = document.getElementById('attach');

    // ==== STATE ====
    const SESSION_KEY = 'n8nchat.session';
    const HISTORY_KEY = 'n8nchat.history';
    let session = localStorage.getItem(SESSION_KEY) || crypto.randomUUID();
    localStorage.setItem(SESSION_KEY, session);
    let history = JSON.parse(localStorage.getItem(HISTORY_KEY) || '[]');

    // Multiple attachments (memory-only; not saved in history)
    let attachedFiles = [];

    // ==== HELPERS ====
    function saveHistory() {
      localStorage.setItem(HISTORY_KEY, JSON.stringify(history));
    }

    // Convert assistant plain text to simple HTML (bold/italic/links/bullets)
    function formatAssistantHTML(text) {
      if (/<[a-z][\s\S]*>/i.test(text)) return text; // already HTML

      let s = text.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
      s = s.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
      s = s.replace(/\*([^*]+)\*/g, '<em>$1</em>');
      s = s.replace(/(https?:\/\/[^\s<]+)/g, '<a href="$1" target="_blank" rel="noopener noreferrer">$1</a>');

      const lines = s.split(/\r?\n/);
      let out = [], inList = false;
      for (const line of lines) {
        const m = line.match(/^\s*\*\s+(.*)/);
        if (m) {
          if (!inList) { out.push('<ul>'); inList = true; }
          out.push('<li>' + m[1] + '</li>');
        } else {
          if (inList) { out.push('</ul>'); inList = false; }
          out.push(line);
        }
      }
      if (inList) out.push('</ul>');
      s = out.join('\n').replace(/\n/g, '<br>');
      return s;
    }

    function addMsg(role, content) {
      const div = document.createElement('div');
      div.className = `msg ${role === 'user' ? 'user' : 'bot'}`;
      if (role === 'assistant') div.innerHTML = formatAssistantHTML(content);
      else div.textContent = content;
      chatEl.appendChild(div);
      chatEl.scrollTop = chatEl.scrollHeight;
    }

    function renderHistory() {
      chatEl.innerHTML = '';
      for (const m of history) addMsg(m.role, m.content);
    }

    function setStatus(t) { statusEl.textContent = t || ''; }

    // Safe File â†’ base64 using FileReader
    function fileToBase64(file) {
      return new Promise((resolve, reject) => {
        const r = new FileReader();
        r.onload = () => {
          const result = r.result || "";
          const comma = result.indexOf(",");
          resolve(comma >= 0 ? result.slice(comma + 1) : result);
        };
        r.onerror = reject;
        r.readAsDataURL(file);
      });
    }

    // ==== INIT ====
    renderHistory();

    // ==== EVENTS ====
    attachBtn.addEventListener('click', () => fileInput.click());

    fileInput.addEventListener('change', () => {
      attachedFiles = Array.from(fileInput.files || []);
      if (attachedFiles.length > 0) {
        const names = attachedFiles.map(f => f.name).join(', ');
        setStatus(`Attached: ${names}`);
      } else {
        setStatus('');
      }
    });

    form.addEventListener('submit', async (e) => {
      e.preventDefault();
      const text = input.value.trim();
      const hasFiles = attachedFiles.length > 0;
      if (!text && !hasFiles) return;
      input.value = '';

      // Labels only in UI/history (never base64)
      if (text) {
        history.push({ role: 'user', content: text });
        addMsg('user', text);
      }
      if (hasFiles) {
        const label = attachedFiles.length === 1
          ? `[File: ${attachedFiles[0].name}]`
          : `[Files: ${attachedFiles.map(f => f.name).join(', ')}]`;
        addMsg('user', label);
      }
      saveHistory();

      // typing indicator
      const typing = { role: 'assistant', content: 'â€¦' };
      history.push(typing); addMsg('assistant', 'â€¦'); setStatus('Thinkingâ€¦');

      try {
        // Size guard
        const tooBig = attachedFiles.find(f => f.size > MAX_BYTES);
        if (tooBig) {
          history = history.filter(m => m !== typing);
          history.push({ role: 'assistant', content: `Error: ${tooBig.name} is too large (> ${Math.round(MAX_BYTES/1024/1024)} MB)` });
          saveHistory(); renderHistory(); setStatus('');
          attachedFiles = []; fileInput.value = '';
          return;
        }

        // Convert all files to base64 (do NOT store in history)
        let filesData = [];
        if (hasFiles) {
          filesData = await Promise.all(attachedFiles.map(async (f) => {
            const data = await fileToBase64(f);
            return { name: f.name, type: f.type, size: f.size, data };
          }));
        }

        const lastLabel = hasFiles
          ? (text ? `${text} ` : '') +
            (attachedFiles.length === 1
              ? `[File: ${attachedFiles[0].name}]`
              : `[Files: ${attachedFiles.map(f => f.name).join(', ')}]`)
          : (text || '');

        const msgsToSend = SEND_ONLY_LAST
          ? [{ role: 'user', content: lastLabel || '(file upload)' }]
          : history.filter(m => m.content !== 'â€¦').slice(-MAX_CONTEXT_TO_SEND);

        const payload = {
          session_id: session,
          messages: msgsToSend,
          last_user_message: lastLabel || '(file upload)',
          files: filesData, // << multiple files here
          metadata: { client: 'static-site', ts: Date.now() }
        };

        const res = await fetch(WORKER_PROXY_URL, {
          method: 'POST',
          headers: { 'content-type': 'application/json' },
          body: JSON.stringify(payload)
        });

        // remove typing
        history = history.filter(m => m !== typing);

        if (!res.ok) {
          const errText = await res.text();
          throw new Error(errText || res.statusText);
        }

        // JSON or text response
        const ct = (res.headers.get('content-type') || '').toLowerCase();
        let reply = '';
        if (ct.includes('application/json')) {
          const data = await res.json();
          reply = (data && (data.reply || data.text || data.message || data.output)) || '[No reply]';
        } else {
          reply = (await res.text()) || '[No reply]';
          try { const data = JSON.parse(reply); reply = data.reply || data.text || data.message || data.output || reply; } catch {}
        }

        history.push({ role: 'assistant', content: reply });
        saveHistory(); renderHistory(); setStatus('');
      } catch (err) {
        history = history.filter(m => m !== typing);
        history.push({ role: 'assistant', content: 'Error: ' + err.message });
        saveHistory(); renderHistory(); setStatus('');
      } finally {
        attachedFiles = [];
        fileInput.value = '';
      }
    });

    // Enter to send (Shift+Enter = newline)
    input.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); form.requestSubmit(); }
    });

    clearBtn.addEventListener('click', () => {
      if (!confirm('Clear conversation?')) return;
      history = [];
      saveHistory();
      renderHistory();
    });

    exportBtn.addEventListener('click', () => {
      const blob = new Blob([JSON.stringify({ session, history }, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = `chat-${session}.json`; a.click();
      URL.revokeObjectURL(url);
    });
  </script>
</body>
</html>
